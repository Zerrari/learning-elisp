* Day1
** symbol
*** it can be defined as a function and a variable which returns a value
*** when symbol is in a pair of parenthese and is the first position.It stands for a function.
**** 
#+begin_src emacs-lisp
(+ 1 2)
#+end_src

#+RESULTS:
: 3

*** when symbol is not in a pair of parenthese it stands for a variable.
**** 
#+begin_src emacs-lisp
fill-column    
#+end_src

#+RESULTS:
: 70

*** a quotation before a pair of parenthese return what is written
#+begin_src emacs-lisp
'(lion tigger)
#+end_src

    #+RESULTS:
    | lion | tigger |

#+begin_src emacs-lisp
'(lion "a tree")
#+end_src

    #+RESULTS:
    | lion | a tree |

*** atoms which in a pair of parenthese are separated by a white space
** evaluate
*** how
move the cursor after the parenthese,and type *C-x C-e* to evaluate the expression

** function
*** something basic
**** a funtion returns two things
+ return a value
+ side effects(/print something on the screen/)
*** set and setq
**** set
     #+begin_src emacs-lisp
     (set 'flowers '(rose))
     flowers
     #+end_src

     #+RESULTS:
     | rose |

**** setq
***** an easy way to use set
***** 
      #+begin_src emacs-lisp 
      (setq animals '(lion tigger))
      animals
      #+end_src

      #+RESULTS:
      | lion | tigger |

**** something important
If you don't add *'* before symbol,it will be explanined as a function.
For example, if you don't add *'* before (lion tigger),the lisp interpretor will think lion is a function.
So it will return a error message.

*** buffer 
**** buffer-name and buffer-file-name
***** buffer-name
It returns the current buffer name
      #+begin_src emacs-lisp
      (buffer-name)
      #+end_src

      #+RESULTS:
      : elisp.org

***** buffer-file-name
It returns a full path which the file belongs to.
      #+begin_src emacs-lisp
      (buffer-file-name)
      #+end_src

      #+RESULTS:
      : /home/zerrari/notes/elisp/elisp.org

**** current-buffer
It returns the name of current buffer.
#+begin_src emacs-lisp
(current-buffer)
#+end_src

#+RESULTS:
: #<buffer elisp.org>

**** other-buffer
It returns the buffer which you visited.
#+begin_src emacs-lisp
(other-buffer)
#+end_src

#+RESULTS:
: #<buffer *scratch*>

**** switch-to-buffer
     #+begin_src emacs-lisp
     (switch-to-buffer (other-buffer))
     #+end_src

     #+RESULTS:
     : #<buffer *scratch*>



* Day2
** function
*** defun 
**** template
(defun fun-name (arguments)
     "optional document"
     (optional interactive)
     (body))
***** example
#+begin_src emacs-lisp
(defun add (x y)
     "add two numbers"
     (+ x y))
(add 3 4) 
#+end_src

#+RESULTS:
: 7

**** interactive(/need input in a minibuffer/)
***** example
#+begin_src emacs-lisp
(defun add (x)
     (interactive "p")  
     (message "The result is %d" (+ x 3)))
#+end_src

#+RESULTS:
: add

**** invoke an interactive function by typing *C-u argument M-x fun-name*
**** *p* stands for prefix which means you should type before invoke a function
*** let
**** template
(let varlist body)
#+begin_src emacs-lisp
(let ((variable value1)
      (variable value2))
      body)
#+end_src
#+begin_src emacs-lisp
(let ((one "apple")
      (two "banana"))
      (message "the fruit is %s" one))
#+end_src

#+RESULTS:
: the fruit is apple

**** something important
unintialized variables will be bond to *nil*
#+begin_src emacs-lisp
(let ((one)
      (two "banana"))
      (message "the fruit is %s" one))
#+end_src

#+RESULTS:
: the fruit is nil

*** if
**** example
#+begin_src emacs-lisp
(if (> 5 4)
     (message "yes")
     (message "no"))
#+end_src

#+RESULTS:
: yes
**** truth and falsehood
+ anything except nil represents true
+ the *empty* list is falsehood

*** save excurison
save the positon of cursor(after evaluating the function,it return the initial location)
**** point and mark
***** point
Point is the current position of the cursor(integer)
***** mark
Mark is another positon of current buffer.
****** mark set
Its value can be set.
type *C-spc* to set mark(it will send a message in minibuffer)
****** mark ring
If you set several marks,it will be recorded in a mark ring.
type *C-u C-spc* to jump to the mark you saved
***** region
The part between point and mark is called a region.
**** template
(save-excurison 
  body...)

*** beginning of buffer
**** push-mark
the function stores the current positon of the cursor in mark ring
#+begin_src emacs-lisp
(defun simple-bob
 (interactive)
 (push-mark)
 (goto-char (point-min)))
#+end_src

#+RESULTS:
: simple-bob

*** mark-whole-buffer
(defun z-mark-whole-buffer()
  (interactive)
  (progn
    (goto-char (point-max))
    (set-mark (point))
    (goto-char (point-min))))
(z-mark-whole-buffer)

*** append-to-buffer
insert-buffer-substring
