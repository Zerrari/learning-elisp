* Day1
** symbol
*** it can be defined as a function and a variable which returns a value
*** when symbol is in a pair of parenthese and is the first position.It stands for a function.
**** 
#+begin_src emacs-lisp
(+ 1 2)
#+end_src

#+RESULTS:
: 3

*** when symbol is not in a pair of parenthese it stands for a variable.
**** 
#+begin_src emacs-lisp
fill-column    
#+end_src

#+RESULTS:
: 70

*** a quotation before a pair of parenthese return what is written
#+begin_src emacs-lisp
'(lion tigger)
#+end_src

#+RESULTS:
| lion | tigger |

#+begin_src emacs-lisp
'(lion "a tree")
#+end_src
#+RESULTS:
| lion | a tree |

*** atoms which in a pair of parenthese are separated by a white space
** evaluate
*** how
move the cursor after the parenthese,and type *C-x C-e* to evaluate the expression

** function
*** something basic
**** a funtion returns two things
+ return a value
+ side effects(/print something on the screen/)
*** set and setq
**** set
#+begin_src emacs-lisp
(set 'flowers '(rose))
flowers
#+end_src

#+RESULTS:
| rose |

**** setq
***** an easy way to use set
***** 
      #+begin_src emacs-lisp 
      (setq animals '(lion tigger))
      animals
      #+end_src

      #+RESULTS:
      | lion | tigger |

**** something important
If you don't add *'* before symbol,it will be explanined as a function.
For example, if you don't add *'* before (lion tigger),the lisp interpretor will think lion is a function.
So it will return a error message.

*** buffer 
**** buffer-name and buffer-file-name
***** buffer-name
It returns the current buffer name
#+begin_src emacs-lisp
(buffer-name)
#+end_src

#+RESULTS:
: elisp.org

***** buffer-file-name
It returns a full path which the file belongs to.
#+begin_src emacs-lisp
(buffer-file-name)
#+end_src

#+RESULTS:
: /home/zerrari/notes/elisp/elisp.org

**** current-buffer
It returns the name of current buffer.
#+begin_src emacs-lisp
(current-buffer)
#+end_src

#+RESULTS:
: #<buffer elisp.org>

**** other-buffer
It returns the buffer which you visited.
#+begin_src emacs-lisp
(other-buffer)
#+end_src

#+RESULTS:
: #<buffer *scratch*>

**** switch-to-buffer
#+begin_src emacs-lisp
(switch-to-buffer (other-buffer))
#+end_src

#+RESULTS:
: #<buffer *scratch*>



* Day2
** function
*** defun 
**** template
#+begin_src emacs-lisp
(defun fun-name (arguments)
     "optional document"
     (optional interactive)
     (body))
#+end_src

**** interactive(/need input in a minibuffer/)
***** example
#+begin_src emacs-lisp
(defun add (x)
     (interactive "p")  
     (message "The result is %d" (+ x 3)))
#+end_src

#+RESULTS:
: add

**** invoke an interactive function by typing *C-u argument M-x fun-name*
**** *p* stands for prefix which means you should type before invoke a function
*** let
**** template
#+begin_src emacs-lisp
(let varlist body)
#+end_src

#+begin_src emacs-lisp
(let ((variable value1)
      (variable value2))
      body)
#+end_src

#+begin_src emacs-lisp
(let ((one "apple")
      (two "banana"))
      (message "the fruit is %s" one))
#+end_src

#+RESULTS:
: the fruit is apple

**** something important
unintialized variables will be bond to *nil*
#+begin_src emacs-lisp
(let ((one)
      (two "banana"))
      (message "the fruit is %s" one))
#+end_src

#+RESULTS:
: the fruit is nil

*** if
**** example
#+begin_src emacs-lisp
(if (> 5 4)
     (message "yes")
     (message "no"))
#+end_src

#+RESULTS:
: yes
**** truth and falsehood
+ anything except nil represents true
+ the *empty* list is falsehood

*** save excurison
save the positon of cursor(after evaluating the function,it return the initial location)
**** point and mark
***** point
Point is the current position of the cursor(integer)
***** mark
Mark is another positon of current buffer.
****** mark set
Its value can be set.
type *C-spc* to set mark(it will send a message in minibuffer)
****** mark ring
If you set several marks,it will be recorded in a mark ring.
type *C-u C-spc* to jump to the mark you saved
***** region
The part between point and mark is called a region.
**** template
#+begin_src emacs-lisp
(save-excurison 
  body...)
#+end_src

*** beginning of buffer
**** push-mark
the function stores the current positon of the cursor in mark ring
#+begin_src emacs-lisp
(defun simple-bob
 (interactive)
 (push-mark)
 (goto-char (point-min)))
#+end_src

#+RESULTS:
: simple-bob

*** mark-whole-buffer
#+begin_src emacs-lisp
(defun z-mark-whole-buffer()
  (interactive)
  (progn
    (goto-char (point-max))
    (set-mark (point))
    (goto-char (point-min))))
(z-mark-whole-buffer)
#+end_src

*** append-to-buffer
insert-buffer-substring


* Day3
** narrowing and widening
with narrowing, the rest of buffer is invisible
*** key binding
*C-x n n* for /narrow-to-rigion/
*C-x n w* for /widen/
** save-restriction
*** use save-restriction and save-excurison
#+begin_src emacs-lisp
(save-excurison
  (save-restriction 
     body))
#+end_src

#+begin_src emacs-lisp
(save-restriction 
  (widen)
  (save-excurison
  body))
#+end_src

** what-lines
*** 
#+begin_src emacs-lisp
(defun simple-whatline()
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (let ((lines))
	(setq  lines (count-lines 1 (point)))
	(message "The line number is %d" lines)))))
#+end_src

#+RESULTS:
: simple-whatline

** more about interactive
Sepreate string with *\n*
*** input many arguments
+ *"s"* string
+ *"n"* number
#+begin_src emacs-lisp
(defun hello(name age country)
  (interactive "sinput your name: \nnage: \nscountry: ")
  (message "name:%s age:%d country:%s" name age country))
#+end_src

#+RESULTS:
: hello

*** "r" stands for a region 
#+begin_src emacs-lisp
(defun hello1 (start end)
  (interactive "r")
  (message "start:%d end:%d" start end))
#+end_src

#+RESULTS:
: hello1

*** "p" and "P"
invoke a function by typing *C-u prefix-argument M-x fun-name*
**** "p" prefix argument convert to a number
**** "P" prefix argument is a raw type
#+begin_src emacs-lisp
(defun hello2 (num)
  (interactive "p")
  (message "%d" num))
#+end_src

#+RESULTS:
: hello2

** car,cdr and cons
+ cons to construct lists
+ car and cdr to take apart lists

*** car 
the car of the list is the first item
#+begin_src emacs-lisp
(car '(tiger lion))
#+end_src

#+RESULTS:
: tiger

*** cdr 
returns the rest of the list
#+begin_src emacs-lisp
(cdr '(tiger lion))
(cdr '(tiger lion cat))
#+end_src

#+RESULTS:
| lion | cat |

*** cons
#+begin_src emacs-lisp
(cons 'tiger '(lion cat))
#+end_src

#+RESULTS:
| tiger | lion | cat |

*** nthcdr
use cdr repeatedly
#+begin_src emacs-lisp
(nthcdr 1 '(tiger lion cat))
#+end_src

#+RESULTS:
| lion | cat |

#+begin_src emacs-lisp
(nthcdr 3 '(tiger lion cat))
#+end_src

#+RESULTS: nil

*** nth
use car repeatedly
#+begin_src emacs-lisp
(nth 1 '(lion tiger cat))
#+end_src

#+RESULTS:
: tiger

*** setcar
set the *car* a new value
#+begin_src emacs-lisp
(setq animals (list 'tiger 'cat 'lion))
(setcar animals 'pig)
animals
#+end_src

#+RESULTS:
| pig | cat | lion |

*** setcdr
set the *cdr* a new value
#+begin_src emacs-lisp
(setq animals (list 'tiger 'cat 'lion))
(setcdr animals (list 'pig 'dog))
animals
#+end_src

#+RESULTS:
| tiger | pig | dog |



* Day4
** defvar
+ it only sets the value of the variable when it doesn't exits
+ if the value has exited,defvar will not overrider the initial value
+ defvar has document string
#+begin_src emacs-lisp
(defvar num 3)
num
#+end_src

#+RESULTS:
: 3

** loops and recursion
*** while 
#+begin_src emacs-lisp
(setq animals '(pig cat tiger dog))
(defun print-list-element (list)
  (while list
   (print (car list))
   (setq list (cdr list))))
(print-list-element animals)nil
#+end_src

*** increment loop
use counter to stop a loop
#+begin_src emacs-lisp
(setq count 1)
(defun counter-stop (num)
  (while (< count num))
   body
   (setq count (+ 1 count))))
  
#+end_src

#+RESULTS:
: counter-stop

*** dolist and dotimes
**** dolist
(dolist element list value)
+ the car of the list is bound to the element
+ the list is bound the cdr of the list
+ the return result is value
#+begin_src emacs-lisp
(setq animals '(cat dog pig))
(defun reverse-list (list)
  (let ((value ()) (element nil))
   (dolist (element list value)
    (setq value (cons element value))))
    (reverse-list animals)
#+end_src

#+RESULTS:

**** dotimes
#+begin_src emacs-lisp
(let ((value nil))
    (dotimes (number 3)
      (message "%d " number)))
#+end_src

#+RESULTS:


