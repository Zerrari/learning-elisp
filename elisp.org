* Day1
** symbol
+ it can be defined as a function and a variable which returns a value
+ when symbol is in a pair of parenthese and is the first position.It stands for a function.
 
#+begin_src emacs-lisp
(+ 1 2)
#+end_src

#+RESULTS:
: 3

+ when symbol is not in a pair of parenthese it stands for a variable.
 
#+begin_src emacs-lisp
fill-column    
#+end_src

#+RESULTS:
: 70

+ a quotation before a pair of parenthese return what is written

#+begin_src emacs-lisp
'(lion tigger)
#+end_src

#+RESULTS:
| lion | tigger |

#+begin_src emacs-lisp
'(lion "a tree")
#+end_src

#+RESULTS:
| lion | a tree |

+ atoms which in a pair of parenthese are separated by a white space
** evaluate
*** how
move the cursor after the parenthese,and type *C-x C-e* to evaluate the expression

** function
*** something basic
**** a funtion returns two things
+ return a value
+ side effects(/print something on the screen/)
*** set and setq
**** set
#+begin_src emacs-lisp
(set 'flowers '(rose))
flowers
#+end_src

#+RESULTS:
| rose |

**** setq
+ an easy way to use set
 
      #+begin_src emacs-lisp 
      (setq animals '(lion tigger))
      animals
      #+end_src

      #+RESULTS:
      | lion | tigger |

**** something important
If you don't add *'* before symbol,it will be explanined as a function.

For example, if you don't add *'* before (lion tigger),

the lisp interpretor will think lion is a function.

So it will return a error message.

*** buffer 
**** buffer-name and buffer-file-name
+ buffer-name
It returns the current buffer name
#+begin_src emacs-lisp
(buffer-name)
#+end_src

#+RESULTS:
: elisp.org

+ buffer-file-name
It returns a full path which the file belongs to.
#+begin_src emacs-lisp
(buffer-file-name)
#+end_src

#+RESULTS:
: /home/zerrari/notes/elisp/elisp.org

**** current-buffer
It returns the name of current buffer.
#+begin_src emacs-lisp
(current-buffer)
#+end_src

#+RESULTS:
: #<buffer elisp.org>

**** other-buffer
It returns the buffer which you visited.
#+begin_src emacs-lisp
(other-buffer)
#+end_src

#+RESULTS:
: #<buffer *scratch*>

**** switch-to-buffer
#+begin_src emacs-lisp
(switch-to-buffer (other-buffer))
#+end_src

#+RESULTS:
: #<buffer *scratch*>



* Day2
** function
*** defun 
+ template
#+begin_src emacs-lisp
(defun fun-name (arguments)
     "optional document"
     (optional interactive)
     (body))
#+end_src

+ interactive(/need input in a minibuffer/)

#+begin_src emacs-lisp
(defun add (x)
     (interactive "p")  
     (message "The result is %d" (+ x 3)))
#+end_src

#+RESULTS:
: add

+ invoke an interactive function by typing *C-u argument M-x fun-name*
+ *p* stands for prefix which means you should type before invoke a function
*** let
+ template
#+begin_src emacs-lisp
(let varlist body)
#+end_src

#+begin_src emacs-lisp
(let ((variable value1)
      (variable value2))
      body)
#+end_src

#+begin_src emacs-lisp
(let ((one "apple")
      (two "banana"))
      (message "the fruit is %s" one))
#+end_src

#+RESULTS:
: the fruit is apple

+ something important
unintialized variables will be bond to *nil*
#+begin_src emacs-lisp
(let ((one)
      (two "banana"))
      (message "the fruit is %s" one))
#+end_src

#+RESULTS:
: the fruit is nil

*** if
+ example
#+begin_src emacs-lisp
(if (> 5 4)
     (message "yes")
     (message "no"))
#+end_src

#+RESULTS:
: yes
+ truth and falsehood
1. anything except nil represents true
2. the *empty* list is falsehood

*** save excurison
save the positon of cursor(after evaluating the function,it return the initial location)
**** point and mark
***** point
Point is the current position of the cursor(integer)
***** mark
Mark is another positon of current buffer.
****** mark set
Its value can be set.
type *C-spc* to set mark(it will send a message in minibuffer)
****** mark ring
If you set several marks,it will be recorded in a mark ring.
type *C-u C-spc* to jump to the mark you saved
***** region
The part between point and mark is called a region.
**** template
#+begin_src emacs-lisp
(save-excurison 
  body...)
#+end_src

*** beginning of buffer
**** push-mark
the function stores the current positon of the cursor in mark ring
#+begin_src emacs-lisp
(defun simple-bob
 (interactive)
 (push-mark)
 (goto-char (point-min)))
#+end_src

#+RESULTS:
: simple-bob

*** mark-whole-buffer
#+begin_src emacs-lisp
(defun z-mark-whole-buffer()
  (interactive)
  (progn
    (goto-char (point-max))
    (set-mark (point))
    (goto-char (point-min))))
(z-mark-whole-buffer)
#+end_src

*** append-to-buffer
insert-buffer-substring


* Day3
** narrowing and widening
with narrowing, the rest of buffer is invisible
*** key binding
*C-x n n* for /narrow-to-rigion/
*C-x n w* for /widen/
** save-restriction
*** use save-restriction and save-excurison
#+begin_src emacs-lisp
(save-excurison
  (save-restriction 
     body))
#+end_src

#+begin_src emacs-lisp
(save-restriction 
  (widen)
  (save-excurison
  body))
#+end_src

** what-lines
*** 
#+begin_src emacs-lisp
(defun simple-whatline()
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (let ((lines))
	(setq  lines (count-lines 1 (point)))
	(message "The line number is %d" lines)))))
#+end_src

#+RESULTS:
: simple-whatline

** more about interactive
Sepreate string with *\n*
*** input many arguments
+ *"s"* string
+ *"n"* number
#+begin_src emacs-lisp
(defun hello(name age country)
  (interactive "sinput your name: \nnage: \nscountry: ")
  (message "name:%s age:%d country:%s" name age country))
#+end_src

#+RESULTS:
: hello

*** "r" stands for a region 
#+begin_src emacs-lisp
(defun hello1 (start end)
  (interactive "r")
  (message "start:%d end:%d" start end))
#+end_src

#+RESULTS:
: hello1

*** "p" and "P"
invoke a function by typing *C-u prefix-argument M-x fun-name*
**** "p" prefix argument convert to a number
**** "P" prefix argument is a raw type
#+begin_src emacs-lisp
(defun hello2 (num)
  (interactive "p")
  (message "%d" num))
#+end_src

#+RESULTS:
: hello2

** car,cdr and cons
+ cons to construct lists
+ car and cdr to take apart lists

*** car 
the car of the list is the first item
#+begin_src emacs-lisp
(car '(tiger lion))
#+end_src

#+RESULTS:
: tiger

*** cdr 
returns the rest of the list
#+begin_src emacs-lisp
(cdr '(tiger lion))
(cdr '(tiger lion cat))
#+end_src

#+RESULTS:
| lion | cat |

*** cons
#+begin_src emacs-lisp
(cons 'tiger '(lion cat))
#+end_src

#+RESULTS:
| tiger | lion | cat |

*** nthcdr
use cdr repeatedly
#+begin_src emacs-lisp
(nthcdr 1 '(tiger lion cat))
#+end_src

#+RESULTS:
| lion | cat |

#+begin_src emacs-lisp
(nthcdr 3 '(tiger lion cat))
#+end_src

#+RESULTS: nil

*** nth
use car repeatedly
#+begin_src emacs-lisp
(nth 1 '(lion tiger cat))
#+end_src

#+RESULTS:
: tiger

*** setcar
set the *car* a new value
#+begin_src emacs-lisp
(setq animals (list 'tiger 'cat 'lion))
(setcar animals 'pig)
animals
#+end_src

#+RESULTS:
| pig | cat | lion |

*** setcdr
set the *cdr* a new value
#+begin_src emacs-lisp
(setq animals (list 'tiger 'cat 'lion))
(setcdr animals (list 'pig 'dog))
animals
#+end_src

#+RESULTS:
| tiger | pig | dog |



* Day4
** defvar
+ it only sets the value of the variable when it doesn't exits
+ if the value has exited,defvar will not overrider the initial value
+ defvar has document string
#+begin_src emacs-lisp
(defvar num 3)
num
#+end_src

#+RESULTS:
: 3

** loops and recursion
*** while 
#+begin_src emacs-lisp
(setq animals '(pig cat tiger dog))
(defun print-list-element (list)
  (while list
   (print (car list))
   (setq list (cdr list))))
(print-list-element animals)nil
#+end_src

*** increment loop
use counter to stop a loop
#+begin_src emacs-lisp
(setq count 1)
(defun counter-stop (num)
  (while (< count num))
   body
   (setq count (+ 1 count))))
  
#+end_src

#+RESULTS:
: counter-stop

*** dolist and dotimes
**** dolist
(dolist element list value)
+ the car of the list is bound to the element
+ the list is bound the cdr of the list
+ the return result is value
#+begin_src emacs-lisp
(setq animals '(cat dog pig))
(defun reverse-list (list)
  (let ((value ()) (element nil))
   (dolist (element list value)
    (setq value (cons element value))))
    (reverse-list animals)
#+end_src

#+RESULTS:

**** dotimes
#+begin_src emacs-lisp
(let ((value nil))
    (dotimes (number 3)
      (message "%d " number)))
#+end_src

#+RESULTS:


* Day5
** numbers
*** basics
+ initial sgin
+ followed by a period
+ two's complement notation to  represent negative number

#+begin_src emacs-lisp
1.
+1
+1.
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(message "%d" most-positive-fixnum)
#+end_src

#+RESULTS:
: 2305843009213693951

#+begin_src emacs-lisp
(message "%d" most-negative-fixnum)
#+end_src

#+RESULTS:
: -2305843009213693952

#+begin_src emacs-lisp
(message "%d" integer-width)
#+end_src

#+RESULTS:
: 65536

#+begin_src emacs-lisp
(isnan 3.0)
#+end_src

#+RESULTS:
: nil
**** frexp
return a cons cell(s . e)
+ s represents significand
+ e represents exponet

3.5 = 0.875*2^2
#+begin_src emacs-lisp
(frexp 3.5)
#+end_src

#+RESULTS:
: (0.875 . 2)

**** ldexp
give s and e, return x

#+begin_src emacs-lisp
(ldexp 0.875 2)
#+end_src

#+RESULTS:
: 3.5

**** copysign
copy sign of x2 to x1 and return the result

#+begin_src emacs-lisp
(copysign x1 x2)
#+end_src

#+begin_src emacs-lisp
(copysign 3.5 -3.5)
#+end_src

#+RESULTS:
: -3.5

**** logb
logarithm base 2 of |x|
round to an integer

#+begin_src emacs-lisp
(logb 2) 1
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(logb 10) 3
#+end_src

#+RESULTS:
: 3
*** type predicates
+ bignump

#+begin_src emacs-lisp
(bignump 2)  nil
#+end_src

#+RESULTS:

+ fixnump

+ floatp

#+begin_src emacs-lisp
(floatp 2) nil
#+end_src

+ integerp

#+begin_src emacs-lisp
(integerp 2) t
#+end_src

+ numberp

+ natnump/wholenump
check if it is a natural number

#+begin_src emacs-lisp
(natnump 3)  t
(natnump -1) nil
#+end_src

#+RESULTS:

+ zerop

#+begin_src emacs-lisp
(zerop 0)  t
#+end_src

#+RESULTS:
: t

*** comparison of numbers
**** *=*
+ numerical equality
+ only accept numbers or markers as arguments

#+begin_src emacs-lisp
(= 2 2)
#+end_src 

#+RESULTS:
: t

#+begin_src emacs-lisp
(= 2 2.0)
#+end_src

#+RESULTS:
: t

**** *equal*
check if their valus are indistinguishable

#+begin_src emacs-lisp
(equal 1 1.0)
#+end_src

#+RESULTS:
: nil

#+begin_src emacs-lisp
(equal 1 1)
#+end_src

#+RESULTS:
: t

**** *eq*
check if they are the same object

#+begin_src emacs-lisp
(eq 1 1) 
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp
(eq 2 2.0) 
#+end_src

#+RESULTS:
: nil

**** max
#+begin_src emacs-lisp
(max 1 2 3)
#+end_src

#+RESULTS:
: 3

**** min

#+begin_src emacs-lisp
(min 1 2 3)
#+end_src

#+RESULTS:
: 1

**** abs
#+begin_src emacs-lisp
(abs -3)
#+end_src

#+RESULTS:
: 3

*** conversion
**** float
convert integer to float

#+begin_src emacs-lisp
(float 3)
#+end_src

#+RESULTS:
: 3.0

#+begin_src emacs-lisp
(float 3.0)
#+end_src

#+RESULTS:
: 3.0

**** convert to integer
+ truncate
rounding towards zero

#+begin_src emacs-lisp
(truncate 1.7)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(truncate 1.2)
#+end_src

#+RESULTS:
: 1

+ floor
rounding downward

#+begin_src emacs-lisp
(floor 1.2)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(floor -1.2)
#+end_src

#+RESULTS:
: -2

+ ceiling
rounding upward

#+begin_src emacs-lisp
(ceiling 1.5)
#+end_src

#+RESULTS:
: 2

#+begin_src emacs-lisp
(ceiling -1.3)
#+end_src

#+RESULTS:
: -1

+ round
rounding towards the nearest integer
if it is a mid-value,round to an even integer

#+begin_src emacs-lisp
(round 1.2)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(round 1.5)
#+end_src

#+RESULTS:
: 2

*** arithmetic operations
**** 1+ / 1-
don't change the value of variable

#+begin_src emacs-lisp
(setq foo 2)
(1+ foo)
foo
#+end_src

#+RESULTS:
: 2

#+begin_src emacs-lisp
(1+ 2)

#+end_src

#+RESULTS:
: 3

**** +

#+begin_src emacs-lisp
(+)
#+end_src

#+RESULTS:
: 0

#+begin_src emacs-lisp
(+ 1 2 3)
#+end_src

#+RESULTS:
: 6

**** -

#+begin_src emacs-lisp
(- 10 1 1 2)
#+end_src

#+RESULTS:
: 6

#+begin_src emacs-lisp
(- 10)
#+end_src

#+RESULTS:
: -10

**** *

#+begin_src emacs-lisp
(*)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(* 1 2 3)
#+end_src

#+RESULTS:
: 6

**** /

#+begin_src emacs-lisp
(/ 26 3 1)
#+end_src

#+RESULTS:
: 8

#+begin_src emacs-lisp
(/ 26 3 1.0)
#+end_src

#+RESULTS:
: 8.666666666666666

#+begin_src emacs-lisp
(/ 3.0)
#+end_src

#+RESULTS:
: 0.3333333333333333

**** %

#+begin_src emacs-lisp
(% 9 4)
#+end_src

#+RESULTS:
: 1

**** mod
accept float argument,unlike %

#+begin_src emacs-lisp
(mod 9 4)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(mod 9 -4)
#+end_src

#+RESULTS:
: -3

*** float rounding
return the float whose value is nearby integer

+ ffloor
#+begin_src emacs-lisp
(ffloor 3.5)
#+end_src

#+RESULTS:
: 3.0

+ fceiling
+ ftruncate
+ fround

*** bitwise operations
**** ash
+ shift the bits left if the argument is positive
+ if it moves right, replace the high position of *0*

#+begin_src emacs-lisp
(ash 7 1)
#+end_src

#+RESULTS:
: 14

#+begin_src emacs-lisp
(ash 8 -1)
#+end_src

#+RESULTS:
: 4

**** lsh

#+begin_src emacs-lisp
(lsh -14 1)
#+end_src

#+RESULTS:
: -28

#+begin_src emacs-lisp
(lsh 14 -1)
#+end_src

#+RESULTS:
: 7

**** logand 
return the bitwise *and* of the arguments

#+begin_src emacs-lisp
(logand 12 13)
#+end_src

#+RESULTS:
: 12

**** logior
return the bitwise *or* of the arguments

#+begin_src emacs-lisp
(logior 12 5)
#+end_src

#+RESULTS:
: 13

**** logxor 
return the bitwise *xor* of the arguments

#+begin_src emacs-lisp
(logxor 12 5)
#+end_src

#+RESULTS:
: 9

**** lognot
return the bitwise *not* of the argument

#+begin_src emacs-lisp
(lognot 5)
#+end_src  

#+RESULTS:
: -6

**** logcount
+ if the integer is positive,return the number of ones
+ else return the number of zeros

#+begin_src emacs-lisp
(logcount 43)
#+end_src

#+RESULTS:
: 4

#+begin_src emacs-lisp
(logcount -43)
#+end_src

#+RESULTS:
: 3

*** mathmatical functions
+ sin
+ cos
+ tan
+ asin
+ acos
+ atan
+ exp
return e to the power *arg*

#+begin_src emacs-lisp
(exp 2)
#+end_src

#+RESULTS:
: 7.38905609893065

+ log

#+begin_src emacs-lisp
(log arg &optional base)
#+end_src
if the base isn't specified,the *e* will be provided defaultly

#+begin_src emacs-lisp
(log (exp 2))
#+end_src

#+RESULTS:
: 2.0

+ expt
return x rasied to the power y

#+begin_src emacs-lisp
(expt x y)
#+end_src

#+begin_src emacs-lisp
(expt 3 2)
#+end_src

#+RESULTS:
: 9

+ sqrt

+ float-e

#+begin_src emacs-lisp
float-e
#+end_src

#+RESULTS:
: 2.718281828459045

+ float-pi

#+begin_src emacs-lisp
float-pi
#+end_src

#+RESULTS:
: 3.141592653589793

*** random numbers
**** set the seed to a constant value

#+begin_src emacs-lisp
(random "")
#+end_src
#+begin_src emacs-lisp

(random 5)
#+end_src

#+RESULTS:
: 1

































































































