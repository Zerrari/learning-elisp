* Day1
** symbol
+ it can be defined as a function and a variable which returns a value
+ when symbol is in a pair of parenthese and is the first position.It stands for a function.
 
#+begin_src emacs-lisp
(+ 1 2)
#+end_src

#+RESULTS:
: 3

+ when symbol is not in a pair of parenthese it stands for a variable.
 
#+begin_src emacs-lisp
fill-column    
#+end_src

#+RESULTS:
: 70

+ a quotation before a pair of parenthese return what is written

#+begin_src emacs-lisp
'(lion tigger)
#+end_src

#+RESULTS:
| lion | tigger |

#+begin_src emacs-lisp
'(lion "a tree")
#+end_src

#+RESULTS:
| lion | a tree |

+ atoms which in a pair of parenthese are separated by a white space
** evaluate
*** how
move the cursor after the parenthese,and type *C-x C-e* to evaluate the expression

** function
*** something basic
**** a funtion returns two things
+ return a value
+ side effects(/print something on the screen/)
*** set and setq
**** set
#+begin_src emacs-lisp
(set 'flowers '(rose))
flowers
#+end_src

#+RESULTS:
| rose |

**** setq
+ an easy way to use set
 
      #+begin_src emacs-lisp 
      (setq animals '(lion tigger))
      animals
      #+end_src

      #+RESULTS:
      | lion | tigger |

**** something important
If you don't add *'* before symbol,it will be explanined as a function.

For example, if you don't add *'* before (lion tigger),

the lisp interpretor will think lion is a function.

So it will return a error message.

*** buffer 
**** buffer-name and buffer-file-name
+ buffer-name
It returns the current buffer name
#+begin_src emacs-lisp
(buffer-name)
#+end_src

#+RESULTS:
: elisp.org

+ buffer-file-name
It returns a full path which the file belongs to.
#+begin_src emacs-lisp
(buffer-file-name)
#+end_src

#+RESULTS:
: /home/zerrari/notes/elisp/elisp.org

**** current-buffer
It returns the name of current buffer.
#+begin_src emacs-lisp
(current-buffer)
#+end_src

#+RESULTS:
: #<buffer elisp.org>

**** other-buffer
It returns the buffer which you visited.
#+begin_src emacs-lisp
(other-buffer)
#+end_src

#+RESULTS:
: #<buffer *scratch*>

**** switch-to-buffer
#+begin_src emacs-lisp
(switch-to-buffer (other-buffer))
#+end_src

#+RESULTS:
: #<buffer *scratch*>



* Day2
** function
*** defun 
+ template

#+begin_src emacs-lisp
(defun fun-name (arguments)
     "optional document"
     (optional interactive)
     (body))
#+end_src

#+RESULTS:
: fun-name

+ interactive(/need input in a minibuffer/)

#+begin_src emacs-lisp
(defun add (x)
     (interactive "p")  
     (message "The result is %d" (+ x 3)))
#+end_src

#+RESULTS:
: add

+ invoke an interactive function by typing *C-u argument M-x fun-name*
+ *p* stands for prefix which means you should type before invoke a function
*** let
+ template
#+begin_src emacs-lisp
(let varlist body)
#+end_src

#+begin_src emacs-lisp
(let ((variable value1)
      (variable value2))
      body)
#+end_src

#+begin_src emacs-lisp
(let ((one "apple")
      (two "banana"))
      (message "the fruit is %s" one))
#+end_src

#+RESULTS:
: the fruit is apple

+ something important
unintialized variables will be bond to *nil*
#+begin_src emacs-lisp
(let ((one)
      (two "banana"))
      (message "the fruit is %s" one))
#+end_src

#+RESULTS:
: the fruit is nil

*** if
+ example
#+begin_src emacs-lisp
(if (> 5 4)
     (message "yes")
     (message "no"))
#+end_src

#+RESULTS:
: yes
+ truth and falsehood
1. anything except nil represents true
2. the *empty* list is falsehood

*** save excurison
save the positon of cursor(after evaluating the function,it return the initial location)
**** point and mark
***** point
Point is the current position of the cursor(integer)
***** mark
Mark is another positon of current buffer.
****** mark set
Its value can be set.
type *C-spc* to set mark(it will send a message in minibuffer)
****** mark ring
If you set several marks,it will be recorded in a mark ring.
type *C-u C-spc* to jump to the mark you saved
***** region
The part between point and mark is called a region.
**** template
#+begin_src emacs-lisp
(save-excurison 
  body...)
#+end_src

*** beginning of buffer
**** push-mark
the function stores the current positon of the cursor in mark ring
#+begin_src emacs-lisp
(defun simple-bob
 (interactive)
 (push-mark)
 (goto-char (point-min)))
#+end_src

#+RESULTS:
: simple-bob

*** mark-whole-buffer
#+begin_src emacs-lisp
(defun z-mark-whole-buffer()
  (interactive)
  (progn
    (goto-char (point-max))
    (set-mark (point))
    (goto-char (point-min))))
(z-mark-whole-buffer)
#+end_src

*** append-to-buffer
insert-buffer-substring


* Day3
** narrowing and widening
with narrowing, the rest of buffer is invisible
*** key binding
*C-x n n* for /narrow-to-rigion/
*C-x n w* for /widen/
** save-restriction
*** use save-restriction and save-excurison
#+begin_src emacs-lisp
(save-excurison
  (save-restriction 
     body))
#+end_src

#+begin_src emacs-lisp
(save-restriction 
  (widen)
  (save-excurison
  body))
#+end_src

** what-lines
*** 
#+begin_src emacs-lisp
(defun simple-whatline()
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (let ((lines))
	(setq  lines (count-lines 1 (point)))
	(message "The line number is %d" lines)))))
#+end_src

#+RESULTS:
: simple-whatline

** more about interactive
Sepreate string with *\n*
*** input many arguments
+ *"s"* string
+ *"n"* number
#+begin_src emacs-lisp
(defun hello(name age country)
  (interactive "sinput your name: \nnage: \nscountry: ")
  (message "name:%s age:%d country:%s" name age country))
#+end_src

#+RESULTS:
: hello

*** "r" stands for a region 
#+begin_src emacs-lisp
(defun hello1 (start end)
  (interactive "r")
  (message "start:%d end:%d" start end))
#+end_src

#+RESULTS:
: hello1

*** "p" and "P"
invoke a function by typing *C-u prefix-argument M-x fun-name*
**** "p" prefix argument convert to a number
**** "P" prefix argument is a raw type
#+begin_src emacs-lisp
(defun hello2 (num)
  (interactive "p")
  (message "%d" num))
#+end_src

#+RESULTS:
: hello2

** car,cdr and cons
+ cons to construct lists
+ car and cdr to take apart lists

*** car 
the car of the list is the first item
#+begin_src emacs-lisp
(car '(tiger lion))
#+end_src

#+RESULTS:
: tiger

*** cdr 
returns the rest of the list
#+begin_src emacs-lisp
(cdr '(tiger lion))
(cdr '(tiger lion cat))
#+end_src

#+RESULTS:
| lion | cat |

*** cons
#+begin_src emacs-lisp
(cons 'tiger '(lion cat))
#+end_src

#+RESULTS:
| tiger | lion | cat |

*** nthcdr
use cdr repeatedly
#+begin_src emacs-lisp
(nthcdr 1 '(tiger lion cat))
#+end_src

#+RESULTS:
| lion | cat |

#+begin_src emacs-lisp
(nthcdr 3 '(tiger lion cat))
#+end_src

#+RESULTS: nil

*** nth
use car repeatedly
#+begin_src emacs-lisp
(nth 1 '(lion tiger cat))
#+end_src

#+RESULTS:
: tiger

*** setcar
set the *car* a new value
#+begin_src emacs-lisp
(setq animals (list 'tiger 'cat 'lion))
(setcar animals 'pig)
animals
#+end_src

#+RESULTS:
| pig | cat | lion |

*** setcdr
set the *cdr* a new value
#+begin_src emacs-lisp
(setq animals (list 'tiger 'cat 'lion))
(setcdr animals (list 'pig 'dog))
animals
#+end_src

#+RESULTS:
| tiger | pig | dog |



* Day4
** defvar
+ it only sets the value of the variable when it doesn't exits
+ if the value has exited,defvar will not overrider the initial value
+ defvar has document string
#+begin_src emacs-lisp
(defvar num 3)
num
#+end_src

#+RESULTS:
: 3

** loops and recursion
*** while 
#+begin_src emacs-lisp
(setq animals '(pig cat tiger dog))
(defun print-list-element (list)
  (while list
   (print (car list))
   (setq list (cdr list))))
(print-list-element animals)nil
#+end_src

*** increment loop
use counter to stop a loop
#+begin_src emacs-lisp
(setq count 1)
(defun counter-stop (num)
  (while (< count num))
   body
   (setq count (+ 1 count))))
  
#+end_src

#+RESULTS:
: counter-stop

*** dolist and dotimes
**** dolist
(dolist element list value)
+ the car of the list is bound to the element
+ the list is bound the cdr of the list
+ the return result is value
#+begin_src emacs-lisp
(setq animals '(cat dog pig))
(defun reverse-list (list)
  (let ((value ()) (element nil))
   (dolist (element list value)
    (setq value (cons element value))))
    (reverse-list animals)
#+end_src

#+RESULTS:

**** dotimes
#+begin_src emacs-lisp
(let ((value nil))
    (dotimes (number 3)
      (message "%d " number)))
#+end_src

#+RESULTS:


* Day5
** numbers
*** basics
+ initial sgin
+ followed by a period
+ two's complement notation to  represent negative number

#+begin_src emacs-lisp
1.
+1
+1.
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(message "%d" most-positive-fixnum)
#+end_src

#+RESULTS:
: 2305843009213693951

#+begin_src emacs-lisp
(message "%d" most-negative-fixnum)
#+end_src

#+RESULTS:
: -2305843009213693952

#+begin_src emacs-lisp
(message "%d" integer-width)
#+end_src

#+RESULTS:
: 65536

#+begin_src emacs-lisp
(isnan 3.0)
#+end_src

#+RESULTS:
: nil
**** frexp
return a cons cell(s . e)
+ s represents significand
+ e represents exponet

3.5 = 0.875*2^2
#+begin_src emacs-lisp
(frexp 3.5)
#+end_src

#+RESULTS:
: (0.875 . 2)

**** ldexp
give s and e, return x

#+begin_src emacs-lisp
(ldexp 0.875 2)
#+end_src

#+RESULTS:
: 3.5

**** copysign
copy sign of x2 to x1 and return the result

#+begin_src emacs-lisp
(copysign x1 x2)
#+end_src

#+begin_src emacs-lisp
(copysign 3.5 -3.5)
#+end_src

#+RESULTS:
: -3.5

**** logb
logarithm base 2 of |x|
round to an integer

#+begin_src emacs-lisp
(logb 2) 1
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(logb 10) 3
#+end_src

#+RESULTS:
: 3
*** type predicates
+ bignump

#+begin_src emacs-lisp
(bignump 2)  nil
#+end_src

#+RESULTS:

+ fixnump

+ floatp

#+begin_src emacs-lisp
(floatp 2) nil
#+end_src

+ integerp

#+begin_src emacs-lisp
(integerp 2) t
#+end_src

+ numberp

+ natnump/wholenump
check if it is a natural number

#+begin_src emacs-lisp
(natnump 3)  t
(natnump -1) nil
#+end_src

#+RESULTS:

+ zerop

#+begin_src emacs-lisp
(zerop 0)  t
#+end_src

#+RESULTS:
: t

*** comparison of numbers
**** *=*
+ numerical equality
+ only accept numbers or markers as arguments

#+begin_src emacs-lisp
(= 2 2)
#+end_src 

#+RESULTS:
: t

#+begin_src emacs-lisp
(= 2 2.0)
#+end_src

#+RESULTS:
: t

**** *equal*
check if their valus are indistinguishable

#+begin_src emacs-lisp
(equal 1 1.0)
#+end_src

#+RESULTS:
: nil

#+begin_src emacs-lisp
(equal 1 1)
#+end_src

#+RESULTS:
: t

**** *eq*
check if they are the same object

#+begin_src emacs-lisp
(eq 1 1) 
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp
(eq 2 2.0) 
#+end_src

#+RESULTS:
: nil

**** max
#+begin_src emacs-lisp
(max 1 2 3)
#+end_src

#+RESULTS:
: 3

**** min

#+begin_src emacs-lisp
(min 1 2 3)
#+end_src

#+RESULTS:
: 1

**** abs
#+begin_src emacs-lisp
(abs -3)
#+end_src

#+RESULTS:
: 3

*** conversion
**** float
convert integer to float

#+begin_src emacs-lisp
(float 3)
#+end_src

#+RESULTS:
: 3.0

#+begin_src emacs-lisp
(float 3.0)
#+end_src

#+RESULTS:
: 3.0

**** convert to integer
+ truncate
rounding towards zero

#+begin_src emacs-lisp
(truncate 1.7)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(truncate 1.2)
#+end_src

#+RESULTS:
: 1

+ floor
rounding downward

#+begin_src emacs-lisp
(floor 1.2)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(floor -1.2)
#+end_src

#+RESULTS:
: -2

+ ceiling
rounding upward

#+begin_src emacs-lisp
(ceiling 1.5)
#+end_src

#+RESULTS:
: 2

#+begin_src emacs-lisp
(ceiling -1.3)
#+end_src

#+RESULTS:
: -1

+ round
rounding towards the nearest integer
if it is a mid-value,round to an even integer

#+begin_src emacs-lisp
(round 1.2)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(round 1.5)
#+end_src

#+RESULTS:
: 2

*** arithmetic operations
**** 1+ / 1-
don't change the value of variable

#+begin_src emacs-lisp
(setq foo 2)
(1+ foo)
foo
#+end_src

#+RESULTS:
: 2

#+begin_src emacs-lisp
(1+ 2)

#+end_src

#+RESULTS:
: 3

**** +

#+begin_src emacs-lisp
(+)
#+end_src

#+RESULTS:
: 0

#+begin_src emacs-lisp
(+ 1 2 3)
#+end_src

#+RESULTS:
: 6

**** -

#+begin_src emacs-lisp
(- 10 1 1 2)
#+end_src

#+RESULTS:
: 6

#+begin_src emacs-lisp
(- 10)
#+end_src

#+RESULTS:
: -10

**** *

#+begin_src emacs-lisp
(*)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(* 1 2 3)
#+end_src

#+RESULTS:
: 6

**** /

#+begin_src emacs-lisp
(/ 26 3 1)
#+end_src

#+RESULTS:
: 8

#+begin_src emacs-lisp
(/ 26 3 1.0)
#+end_src

#+RESULTS:
: 8.666666666666666

#+begin_src emacs-lisp
(/ 3.0)
#+end_src

#+RESULTS:
: 0.3333333333333333

**** %

#+begin_src emacs-lisp
(% 9 4)
#+end_src

#+RESULTS:
: 1

**** mod
accept float argument,unlike %

#+begin_src emacs-lisp
(mod 9 4)
#+end_src

#+RESULTS:
: 1

#+begin_src emacs-lisp
(mod 9 -4)
#+end_src

#+RESULTS:
: -3

*** float rounding
return the float whose value is nearby integer

+ ffloor
#+begin_src emacs-lisp
(ffloor 3.5)
#+end_src

#+RESULTS:
: 3.0

+ fceiling
+ ftruncate
+ fround

*** bitwise operations
**** ash
+ shift the bits left if the argument is positive
+ if it moves right, replace the high position of *0*

#+begin_src emacs-lisp
(ash 7 1)
#+end_src

#+RESULTS:
: 14

#+begin_src emacs-lisp
(ash 8 -1)
#+end_src

#+RESULTS:
: 4

**** lsh

#+begin_src emacs-lisp
(lsh -14 1)
#+end_src

#+RESULTS:
: -28

#+begin_src emacs-lisp
(lsh 14 -1)
#+end_src

#+RESULTS:
: 7

**** logand 
return the bitwise *and* of the arguments

#+begin_src emacs-lisp
(logand 12 13)
#+end_src

#+RESULTS:
: 12

**** logior
return the bitwise *or* of the arguments

#+begin_src emacs-lisp
(logior 12 5)
#+end_src

#+RESULTS:
: 13

**** logxor 
return the bitwise *xor* of the arguments

#+begin_src emacs-lisp
(logxor 12 5)
#+end_src

#+RESULTS:
: 9

**** lognot
return the bitwise *not* of the argument

#+begin_src emacs-lisp
(lognot 5)
#+end_src  

#+RESULTS:
: -6

**** logcount
+ if the integer is positive,return the number of ones
+ else return the number of zeros

#+begin_src emacs-lisp
(logcount 43)
#+end_src

#+RESULTS:
: 4

#+begin_src emacs-lisp
(logcount -43)
#+end_src

#+RESULTS:
: 3

*** mathmatical functions
+ sin
+ cos
+ tan
+ asin
+ acos
+ atan
+ exp
return e to the power *arg*

#+begin_src emacs-lisp
(exp 2)
#+end_src

#+RESULTS:
: 7.38905609893065

+ log

#+begin_src emacs-lisp
(log arg &optional base)
#+end_src
if the base isn't specified,the *e* will be provided defaultly

#+begin_src emacs-lisp
(log (exp 2))
#+end_src

#+RESULTS:
: 2.0

+ expt
return x rasied to the power y

#+begin_src emacs-lisp
(expt x y)
#+end_src

#+begin_src emacs-lisp
(expt 3 2)
#+end_src

#+RESULTS:
: 9

+ sqrt

+ float-e

#+begin_src emacs-lisp
float-e
#+end_src

#+RESULTS:
: 2.718281828459045

+ float-pi

#+begin_src emacs-lisp
float-pi
#+end_src

#+RESULTS:
: 3.141592653589793

*** random numbers
**** set the seed to a constant value

#+begin_src emacs-lisp
(random "")
#+end_src
#+begin_src emacs-lisp

(random 5)
#+end_src

#+RESULTS:
: 1


































































































* Day6
** strings and characters
*** predicates for strings
**** stringp
This function returns t if object is a string, nil otherwise

#+begin_src emacs-lisp
(stringp "asd")  t
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp
(stringp nil)  nil
#+end_src

#+RESULTS:

**** string-or-null-p
This function returns t if object is a string or nil. It returns nil otherwise.

#+begin_src emacs-lisp
(string-or-null-p nil) t
#+end_src

#+RESULTS:
: t

**** char-or-string-p
This function returns t if object is a string or a character (i.e., an integer), nil otherwise.

#+begin_src emacs-lisp
(char-or-string-p ?a) t
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp
(char-or-string-p "asdf") t
#+end_src

#+RESULTS:
: t

*** creating strings
**** make-string
#+begin_src emacs-lisp
(make-string count character &optional multibyte)
#+end_src

#+begin_src emacs-lisp
(make-string 5 ?x)  "xxxxx"
#+end_src

#+RESULTS:
: xxxxx

**** string
#+begin_src emacs-lisp
(string &rest characters)
#+end_src

#+begin_src emacs-lisp
(string ?a ?d) "ad"
#+end_src

#+RESULTS:
: ad

**** substring
+ include the start,exclude the end
+ a negative argument is accpeted (-1 stands for the last index)
+ default start stands for 0,end stands for the length of the string
#+begin_src emacs-lisp
(substring string &optional start end)
#+end_src

#+begin_src emacs-lisp
(substring "asdfg" 1)    "sdfg"
#+end_src

#+RESULTS:
: sdfg

#+begin_src emacs-lisp
(substring "asdfg" -2 -1)  "f"
#+end_src

#+RESULTS:
: f

**** concat
#+begin_src emacs-lisp
(concat &rest sequences)
#+end_src

#+begin_src emacs-lisp
(concat "sda" "sad") "sdasad"
#+end_src

#+RESULTS:
: sdasad

if concat receives no argun=ments,it returns empty string.
#+begin_src emacs-lisp
(concat)  ""
#+end_src

#+RESULTS:

**** split-string
#+begin_src emacs-lisp
(split-string string &optional separators omit-nulls trim)
#+end_src

#+begin_src emacs-lisp
(split-string "hello world")  "hello" "world"
#+end_src

#+RESULTS:
| hello | world |

#+begin_src emacs-lisp
(split-string "  hello world   ")
#+end_src

#+RESULTS:
| hello | world |

*** modifying strings
**** store-substring
#+begin_src emacs-lisp
(store-substring string idx obj)
#+end_src

#+begin_src emacs-lisp
(store-substring "asdfg" 1 "asd")  aasdg
#+end_src

#+RESULTS:
: aasdg

**** aset
#+begin_src emacs-lisp
(aset string idx char)
#+end_src

#+begin_src emacs-lisp
?????(aset "asdfg" 1 ?a)

#+end_src

#+RESULTS:
: 97

**** clear-string
+ It clears its contents to zero
#+begin_src emacs-lisp
(clear-string string)
#+end_src

#+begin_src emacs-lisp
(clear-string "asdad") nil
#+end_src

#+RESULTS:

*** comparison of character and strings
#+begin_src emacs-lisp
(char-equal character1 character2)
#+end_src

#+begin_src emacs-lisp
(char-equal ?a ?c) nil
#+end_src

#+RESULTS:

If case-fold-search is non-nil,this function ignores differences in case
#+begin_src emacs-lisp
(char-equal ?a ?A)   t
(setq case-fold-search nil)
(char-equal ?a ?A)   nil
#+end_src

#+RESULTS:
: t

**** string= / string-equal
#+begin_src emacs-lisp
(string= string1 string2)
#+end_src

#+begin_src emacs-lisp
(string= "asdf" "asdf")  t
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp
(string= "asdf" "asd")  nil
#+end_src

#+RESULTS:


**** string< / string-lessp
+ a string has no characters which is less than any other string

#+begin_src emacs-lisp
(string< string1 string2)
#+end_src

#+begin_src emacs-lisp
(string< "" "sad")  t
#+end_src

#+RESULTS:
: t


#+begin_src emacs-lisp
(string< "sad" "sadf")  t
#+end_src

#+RESULTS:
: t

**** string-version-lessp
+ It trests sequences of numbers as if they comprised a base-ten number,then compare them.
#+begin_src emacs-lisp
(string-version-lessp string1 string2)
#+end_src

#+begin_src emacs-lisp
(string-version-lessp "12" "1") nil
#+end_src

#+RESULTS:

#+begin_src emacs-lisp
(string-version-lessp "foo2.png" "foo12.png")   t
#+end_src

#+RESULTS:
: t

**** string-prefix-p
+ This function returns non-nil,if string1 is a prefix of string2.
+ If the ignore-case is non-nil,the comparison ignores case differences.
#+begin_src emacs-lisp
(string-prefix-p string1 string2 &optional ignore-case)
#+end_src

#+begin_src emacs-lisp
(string-prefix-p "asdf" "asdfg" 1)  t
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp
(string-prefix-p "asdf" "ASDFF" nil) nil
#+end_src

**** string-suffix-p
#+begin_src emacs-lisp
(string-suffix-p "asdf" "AASDF" 1) t
#+end_src

#+begin_src emacs-lisp
(string-suffix-p "asdf" "AASDF") nil
#+end_src

**** compare-strings
+ If the parts of strings match,it returns t
+ Otherwise,the value is an integer which how many leading characters agree.
+ The sign is negative if the string1 is less.
#+begin_src emacs-lisp
(compare-strings string1 start1 end1 string2 start2 end2 &optional ignore-case)
#+end_src

#+begin_src emacs-lisp
(compare-strings "asdfg" 0 3 "dfgasd" 3 6)  t
#+end_src

#+RESULTS:
: t

**** string-distance
#+begin_src emacs-lisp
(string-distance string1 string2 &optional bytecompare)
#+end_src

+ It returns the Levenshtein distance.

#+begin_src emacs-lisp
(string-distance "asdf" "asd")  1
#+end_src

#+RESULTS:
: 1

*** conversion of characters and strings
**** number-to-string
#+begin_src emacs-lisp
(number-to-string number)
#+end_src

#+begin_src emacs-lisp
(number-to-string 123)  "123"
#+end_src

#+RESULTS:
: 123

#+begin_src emacs-lisp
(number-to-string -23)  "-23"
#+end_src

#+RESULTS:
: -23

**** string-to-number
#+begin_src emacs-lisp
(string-to-number string &optional base)
#+end_src

#+begin_src emacs-lisp
(string-to-number "1234")  1234
#+end_src

#+RESULTS:
: 1234

#+begin_src emacs-lisp
(string-to-number "asd123")  0
#+end_src

#+RESULTS:
: 0

#+begin_src emacs-lisp
(string-to-number "      23 apples")  23
#+end_src

#+RESULTS:
: 23

#+begin_src emacs-lisp
(string-to-number "23" 8) 19
#+end_src

#+RESULTS:
: 19


**** char-to-string
#+begin_src emacs-lisp
(char-to-string character)
#+end_src

#+begin_src emacs-lisp
(char-to-string ?a)  "a"
#+end_src

**** (string-to-char)
+ The function returns the first character of the string.
+ If the string is empty,it returns 0.
#+begin_src emacs-lisp
(string-to-char string)
#+end_src

#+begin_src emacs-lisp
(string-to-char "ASD") ?A
#+end_src

#+begin_src emacs-lisp
(string-to-char "") 0
#+end_src

**** formatting strings
#+begin_src emacs-lisp
(format string &rest objects)
#+end_src

#+begin_src emacs-lisp
(format "ASD")  "ASD"
#+end_src

#+RESULTS:
: ASD

***** valid format specifications
+ %s 
print without "" 
#+begin_src emacs-lisp
(format "This is an %s" "apple") "This is an apple"
#+end_src

#+RESULTS:
: This is an apple

+ %S
print with "" and \
#+begin_src emacs-lisp
(format "This is an %S" "apple")  "This is an \"apple\""
#+end_src

#+RESULTS:
: This is an "apple"

+ %o
replace the specification with the base-eight number
It also accepts float point as an integer,droppong any fraction
#+begin_src emacs-lisp
(format "%o" 23)  "27"
#+end_src

#+RESULTS:
: 27

#+begin_src emacs-lisp
(format "%o" 23.5)  "27"
#+end_src

#+RESULTS:
: 27

+ %x
base-sixteen
with lower case
#+begin_src emacs-lisp
(format "%x" 29)  "1d"
#+end_src

#+RESULTS:
: 1d

+ %X
base-sixteen 
with upper case
#+begin_src emacs-lisp
(format "%X" 29)  "1D"
#+end_src

#+RESULTS:
: 1D

+ %c
repalce the specification with the character
#+begin_src emacs-lisp
(format "This is %c" ?a) "This is a"
#+end_src

#+RESULTS:
: This is a

+ %f
#+begin_src emacs-lisp
(format "%f" 13.5)  "13.500000"
#+end_src

#+RESULTS:
: 13.500000

+ %%
replace the specification with single "%"

***** field numbers in specification
It causes the format specification to convert the argument with the given number.
#+begin_src emacs-lisp
(format "%s %1$s %% %3$s" "x" "y" "z")  "x x % z"
#+end_src

#+RESULTS:
: x x % z

***** flag characters
After the '%' and field numbers,ypu can put flag characters.
+ '+'
a plus sign before a nonnegative number
#+begin_src emacs-lisp
(format "%+d" 23)   "+23"
#+end_src

#+RESULTS:
: +23

+ '#'
#+begin_src emacs-lisp
(format "%#o" 23)   "027"
#+end_src

#+RESULTS:
: 027

#+begin_src emacs-lisp
(format "%#x" 29)  "0x1d"
#+end_src

#+RESULTS:
: 0x1d

+ '0'
the padding consists of '0' characters instead of spaces
this flag is ingored for specification like "%s" "%S" or "%c"
#+begin_src emacs-lisp
(format "%06d" 23) "000023"
#+end_src

#+RESULTS:
: 000023

#+begin_src emacs-lisp
(format "%6d" 23)  "      23"
#+end_src

#+RESULTS:
:     23

+ '-'
the flag causes any padding inserted on the right
If both '0' and '-' are present,'0' is ignored.
#+begin_src emacs-lisp
(format "%-06d" 23)   "23      "
#+end_src

#+RESULTS:
: 23    

#+begin_src emacs-lisp
(format "%-6d" 23)    "23      "
#+end_src

#+RESULTS:
: 23


**** format-message
#+begin_src emacs-lisp
(format-message string &rest objects)
#+end_src

#+begin_src emacs-lisp
(format-message "'asdf'")  'asdf'
#+end_src

#+RESULTS:
: ’asdf’

**** 

